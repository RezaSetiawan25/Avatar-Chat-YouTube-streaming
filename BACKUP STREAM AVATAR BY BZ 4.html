<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Avatar Chat YouTube Mod by Bungza (Custom Owner Bubble)</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            /* Pastikan body dan html mengambil 100% tinggi dan lebar viewport */
            width: 100vw; 
            height: 100vh;
            overflow: hidden; /* Mencegah scroll jika ada elemen melebihi viewport */
            background-color: transparent !important;
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            display: block;
            border: 2px solid yellow; /* Aktifkan kembali border canvas */
            /* Canvas akan diatur ukurannya via JS, ini sebagai fallback */
            max-width: 100vw; 
            max-height: 100vh;
        }
        #controlPanel {
            position: fixed;
            top: 60px; /* Jarak dari atas, beri ruang untuk tombol toggle */
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            color: white;
            font-family: Arial, sans-serif;
            z-index: 100;
            width: 320px;
            max-height: calc(100vh - 70px); /* Batasi tinggi panel agar bisa di-scroll, sesuaikan dengan top offset */
            overflow-y: auto; /* Aktifkan scroll vertikal */
            backdrop-filter: blur(5px);
            transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out; /* Transisi untuk hide/show */
            transform: translateX(0); /* Default: terlihat */
            opacity: 1;
            pointer-events: auto;
        }
        #controlPanel.hidden {
            transform: translateX(calc(100% + 10px)); /* Geser ke kanan untuk menyembunyikan, lebih jauh dari tombol */
            opacity: 0;
            pointer-events: none; /* Nonaktifkan interaksi saat tersembunyi */
        }
        #toggleControlPanel {
            position: fixed;
            top: 10px;
            right: 10px; /* Posisikan tombol selalu di kanan atas */
            width: 40px; 
            height: 40px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 50%; 
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            z-index: 101; /* Lebih tinggi dari panel */
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s; /* Hanya transisi warna */
        }
        #toggleControlPanel:hover {
            background: rgba(0, 0, 0, 0.9);
        }

        #characterList {
            margin-top: 10px;
            max-height: 200px;
            overflow-y: auto;
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border-radius: 5px;
        }
        input, label, button {
            display: block;
            margin-top: 8px;
            width: 100%;
            box-sizing: border-box;
        }
        #errorMessage {
            color: #ff6b6b;
            font-size: 14px;
            margin-top: 10px;
            word-break: break-word;
        }
        .status {
            color: #7eff7e;
            font-size: 14px;
            margin-top: 8px;
        }
        /* Buttons general style (excluding toggleControlPanel) */
        button:not(#toggleControlPanel) {
            padding: 8px;
            margin-top: 12px;
            cursor: pointer;
            background: #4285f4;
            color: white;
            border: none;
            border-radius: 4px;
            transition: background 0.2s;
            font-weight: bold;
        }
        button:not(#toggleControlPanel):hover {
            background: #3367d6;
        }
        button:not(#toggleControlPanel):disabled {
            background: #666;
            cursor: not-allowed;
        }
        .character-thumb {
            width: 50px;
            height: 50px;
            object-fit: contain;
            margin: 5px;
            border: 2px solid rgba(255,255,255,0.5);
            display: inline-block;
            vertical-align: middle;
            background: rgba(0,0,0,0.3);
            border-radius: 5px;
        }
        .progress-bar {
            width: 100%;
            background: rgba(255,255,255,0.2);
            border-radius: 3px;
            margin-top: 10px;
        }
        .progress {
            height: 4px;
            background: #4285f4;
            border-radius: 3px;
            width: 0%;
            transition: width 0.3s;
        }
        #fileInfo {
            font-size: 12px;
            margin-top: 5px;
            color: #ccc;
        }
        #watermark {
            position: fixed;
            top: 10px;
            left: 10px;
            color: black;
            font-size: 12px;
            font-family: sans-serif;
            z-index: 99;
        }
        #socialButtons {
            position: fixed;
            top: 40px;
            left: 10px;
            z-index: 99;
        }
        #donationButton, #youtubeButton {
            background: #ff9800;
            color: white;
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 10px;
            display: block;
        }
        #youtubeButton {
            background: #e52d27;
            margin-top: 5px;
        }
        #sizeControls {
            margin-top: 10px;
        }
        #sizeControls label {
            display: inline-block;
            width: auto;
            margin-right: 10px;
        }
        #sizeControls input[type="range"] {
            display: inline-block;
            width: 70%;
        }
        #avatarPreview {
            width: 100px;
            height: 100px;
            border: 2px solid white;
            display: inline-block;
            vertical-align: middle;
            margin-left: 10px;
            background-color: rgba(0,0,0,0.3);
        }
        /* Style for range input value display */
        .range-value {
            display: inline-block;
            width: 40px; /* Fixed width for consistent alignment */
            text-align: right;
            margin-left: 5px;
            color: #fff;
        }
    </style>
</head>
<body>
    <canvas id="avatarCanvas"></canvas>

    <div id="controlPanel">
        <h3 style="margin-top: 0; border-bottom: 1px solid #444; padding-bottom: 10px;">Avatar Chat YouTube by Bungza (Modified)</h3>

        <label for="addCharacter">Upload Sprite Sheet karakter(PNG):</label>
        <input type="file" id="addCharacter" accept="image/png, image/gif" multiple />
        <div id="fileInfo">Belum ada file dipilih</div>
        <div class="progress-bar"><div id="uploadProgress" class="progress"></div></div>

        <label for="apiKey">Kunci API YouTube:</label>
        <input type="text" id="apiKey" placeholder="Masukkan kunci API YouTube" />

        <label for="videoId">ID Video YouTube:</label>
        <input type="text" id="videoId" placeholder="Masukkan ID video live" />

        <button id="startButton">Mulai</button>
        <div id="status" class="status">Siap menghubungkan</div>

        <div id="characterList">
            <div style="color: #aaa; text-align: center;">Belum ada karakter dimuat</div>
        </div>

        <div id="errorMessage"></div>
        <div id="sizeControls">
            <div>
                <label for="canvasWidth">Lebar Canvas:</label>
                <input type="range" id="canvasWidth" min="100" max="1920" value="1280">
                <span class="range-value" id="canvasWidthValue">1280</span>
            </div>
            <div>
                <label for="canvasHeight">Tinggi Canvas:</label>
                <input type="range" id="canvasHeight" min="100" max="1080" value="720">
                <span class="range-value" id="canvasHeightValue">720</span>
            </div>
            <div>
                <label for="avatarSize">Ukuran Avatar:</label>
                <input type="range" id="avatarSize" min="50" max="200" value="100">
                <span class="range-value" id="avatarSizeValue">100</span>
                <div id="avatarPreview"></div>
            </div>
            <div>
                <label for="avatarDuration">Durasi Avatar (detik):</label>
                <input type="range" id="avatarDuration" min="5" max="60" value="10">
                <span class="range-value" id="avatarDurationValue">10</span>
            </div>
            <div>
                <label for="avatarSpeed">Kecepatan Avatar:</label>
                <input type="range" id="avatarSpeed" min="0.1" max="5" step="0.1" value="1">
                <span class="range-value" id="avatarSpeedValue">1.0</span>
            </div>
        </div>
    </div>

    <button id="toggleControlPanel" title="Hide Control Panel">âœ•</button>

    <div id="watermark">Dibuat menggunakan AI yang dipandu oleh Bungza</div>

    <div id="socialButtons">
        <a href="https://saweria.co/bungza" target="_blank"><button id="donationButton">Donasi</button></a>
        <a href="https://www.youtube.com/@Bung-za" target="_blank"><button id="youtubeButton">YouTube Channel</button></a>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>
    <script>
        const canvas = document.getElementById('avatarCanvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const canvasWidthInput = document.getElementById('canvasWidth');
        const canvasHeightInput = document.getElementById('canvasHeight');
        const avatarSizeInput = document.getElementById('avatarSize');
        const avatarDurationInput = document.getElementById('avatarDuration'); 
        const avatarSpeedInput = document.getElementById('avatarSpeed'); 
        const avatarPreview = document.getElementById('avatarPreview');

        const canvasWidthValue = document.getElementById('canvasWidthValue');
        const canvasHeightValue = document.getElementById('canvasHeightValue');
        const avatarSizeValue = document.getElementById('avatarSizeValue');
        const avatarDurationValue = document.getElementById('avatarDurationValue');
        const avatarSpeedValue = document.getElementById('avatarSpeedValue'); 

        // --- Initial setup of canvas dimensions based on inputs AND window size ---
        function setCanvasDimensions() {
            const desiredWidth = parseInt(canvasWidthInput.value);
            const desiredHeight = parseInt(canvasHeightInput.value);

            // Set canvas width/height to the minimum of desired and actual viewport size
            canvas.width = Math.min(desiredWidth, window.innerWidth);
            canvas.height = Math.min(desiredHeight, window.innerHeight);
            drawAllAvatars(); // Redraw if canvas size changes
        }

        // Update range value displays and canvas size
        canvasWidthInput.addEventListener('input', () => {
            canvasWidthValue.textContent = canvasWidthInput.value;
            setCanvasDimensions();
        });

        canvasHeightInput.addEventListener('input', () => {
            canvasHeightValue.textContent = canvasHeightInput.value;
            setCanvasDimensions();
        });

        avatarSizeInput.addEventListener('input', () => {
            const size = parseInt(avatarSizeInput.value);
            avatarPreview.style.width = `${size}px`;
            avatarPreview.style.height = `${size}px`;
            avatarSizeValue.textContent = avatarSizeInput.value;
        });

        avatarDurationInput.addEventListener('input', () => {
            avatarDurationValue.textContent = avatarDurationInput.value;
        });

        avatarSpeedInput.addEventListener('input', () => {
            avatarSpeedValue.textContent = parseFloat(avatarSpeedInput.value).toFixed(1); 
        });


        let characters = []; 
        let activeAvatars = []; 
        let isRunning = false; 
        let pollTimeout; 
        let nextPageToken = ''; 
        let pollingInterval = 3000; 
        let processedMessageIds = new Set(); 
        let ownerChannelId = null; 

        const subscriberBubbleColors = [
            'rgba(66, 133, 244, 0.7)', 
            'rgba(234, 67, 53, 0.7)',  
            'rgba(52, 168, 83, 0.7)',  
            'rgba(251, 188, 5, 0.7)',  
            'rgba(142, 68, 173, 0.7)', 
            'rgba(26, 188, 156, 0.7)', 
            'rgba(243, 156, 18, 0.7)', 
            'rgba(192, 57, 43, 0.7)'   
        ];

        const startButton = document.getElementById('startButton');
        const statusElement = document.getElementById('status');
        const errorElement = document.getElementById('errorMessage');
        const fileInfoElement = document.getElementById('fileInfo');
        const progressBar = document.getElementById('uploadProgress');
        const controlPanel = document.getElementById('controlPanel');
        const toggleControlPanelBtn = document.getElementById('toggleControlPanel');

        // Initial updates for all range values and toggle button text
        canvasWidthInput.dispatchEvent(new Event('input'));
        canvasHeightInput.dispatchEvent(new Event('input'));
        avatarSizeInput.dispatchEvent(new Event('input'));
        avatarDurationInput.dispatchEvent(new Event('input'));
        avatarSpeedInput.dispatchEvent(new Event('input')); 
        
        toggleControlPanelBtn.textContent = 'âœ•'; 
        toggleControlPanelBtn.title = 'Hide Control Panel'; 

        // Initial canvas dimension setup
        setCanvasDimensions();


        // Toggle control panel visibility
        toggleControlPanelBtn.addEventListener('click', () => {
            controlPanel.classList.toggle('hidden');
            if (controlPanel.classList.contains('hidden')) {
                toggleControlPanelBtn.textContent = 'â˜°'; 
                toggleControlPanelBtn.title = 'Show Control Panel';
            } else {
                toggleControlPanelBtn.textContent = 'âœ•'; 
                toggleControlPanelBtn.title = 'Hide Control Panel';
            }
        });

        // Add resize listener for window to ensure canvas doesn't exceed viewport
        window.addEventListener('resize', setCanvasDimensions);


        async function loadImage(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = function(event) {
                    const img = new Image();
                    img.onload = () => resolve(img);
                    img.onerror = () => reject(`Gagal memuat: ${file.name}`);
                    img.src = event.target.result;
                };
                reader.onerror = () => reject(`Gagal membaca file: ${file.name}`);
                reader.readAsDataURL(file);
            });
        }

        async function loadGifFrames(file) {
            return new Promise(async (resolve, reject) => {
                try {
                    const img = await loadImage(file);
                    if (!img.src.startsWith('data:image/gif')) {
                        const frameWidth = 100; 
                        const frameHeight = 100; 
                        const frames = [];
                        
                        const numColumns = Math.floor(img.width / frameWidth);
                        const numRows = Math.floor(img.height / frameHeight);

                        if (numColumns === 0 || numRows === 0) {
                             reject(`Gambar ${file.name} terlalu kecil atau tidak dapat dibagi menjadi frame 100x100px.`);
                             return;
                        }

                        for (let y = 0; y < numRows; y++) {
                            for (let x = 0; x < numColumns; x++) {
                                const canvasFrame = document.createElement('canvas');
                                canvasFrame.width = frameWidth;
                                canvasFrame.height = frameHeight;
                                const ctxFrame = canvasFrame.getContext('2d');
                                ctxFrame.drawImage(img, x * frameWidth, y * frameHeight, frameWidth, frameHeight, 0, 0, frameWidth, frameHeight);

                                const imageData = ctxFrame.getImageData(0, 0, frameWidth, frameHeight).data;
                                let hasContent = false;
                                for (let i = 0; i < imageData.length; i += 4) {
                                    if (imageData[i + 3] > 0) { 
                                        hasContent = true;
                                        break;
                                    }
                                }
                                if (hasContent) {
                                    frames.push({ img: canvasFrame, delay: 100 }); 
                                }
                                hasContent = false; 
                            }
                        }

                        if (frames.length === 0) {
                            reject(`Sprite sheet kosong atau tidak valid: ${file.name}`);
                            return;
                        }
                        resolve(frames);
                        return;
                    }

                    const gif = new GIF();
                    gif.onload = () => {
                        const frames = gif.frames.map(frame => ({
                            img: frame.image,
                            delay: frame.delay
                        }));
                        resolve(frames);
                    };
                    gif.onerror = (error) => reject(`Gagal memuat GIF: ${error}`);
                    gif.load(img.src);
                } catch (error) {
                    reject(error);
                }
            });
        }

        document.getElementById('addCharacter').addEventListener('change', async function(e) {
            const files = e.target.files;
            if (!files || files.length === 0) return;

            fileInfoElement.textContent = `Memuat ${files.length} file...`;
            progressBar.style.width = '0%';

            let loadedCount = 0;
            const totalFiles = files.length;

            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                try {
                    const frames = await loadGifFrames(file);
                    characters.push({
                        frames: frames,
                        name: file.name.replace(/\.[^/.]+$/, ""), 
                        currentFrame: 0,
                        lastFrameTime: Date.now()
                    });
                    loadedCount++;

                    progressBar.style.width = `${(loadedCount / totalFiles) * 100}%`;
                    fileInfoElement.textContent = `Memuat ${loadedCount}/${totalFiles}: ${file.name}`;

                    if (loadedCount === totalFiles) {
                        updateCharacterList();
                        updateStatus(`Berhasil memuat ${loadedCount} karakter`);
                        fileInfoElement.textContent = `Berhasil memuat ${loadedCount} karakter`;
                        setTimeout(() => progressBar.style.width = '0%', 2000);
                    }
                } catch (error) {
                    loadedCount++;
                    showError(`Gagal memuat: ${file.name} - ${error}`);
                }
            }
        });

        function updateCharacterList() {
            const container = document.getElementById('characterList');
            container.innerHTML = characters.length > 0 ? '<div style="margin-bottom: 8px;">Karakter Tersedia:</div>' : '<div style="color: #aaa; text-align: center;">Belum ada karakter dimuat</div>';

            characters.forEach((char, index) => {
                const thumbContainer = document.createElement('div');
                thumbContainer.style.display = 'inline-block';
                thumbContainer.style.position = 'relative';
                thumbContainer.style.margin = '5px';

                const thumb = document.createElement('img');
                thumb.src = char.frames[0].img.src;
                thumb.className = 'character-thumb';
                thumb.title = `${char.name} (${char.frames[0].img.width}Ã—${char.frames[0].img.height}px)`;

                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'Ã—';
                deleteBtn.style.position = 'absolute';
                deleteBtn.style.top = '-8px';
                deleteBtn.style.right = '-8px';
                deleteBtn.style.padding = '2px 6px';
                deleteBtn.style.borderRadius = '50%';
                deleteBtn.style.background = 'red';
                deleteBtn.style.fontSize = '12px';
                deleteBtn.style.border = '2px solid white';
                deleteBtn.onclick = (e) => {
                    e.stopPropagation();
                    characters.splice(index, 1);
                    updateCharacterList();
                    updateStatus(`Karakter dihapus. Total: ${characters.length}`);
                };

                thumbContainer.appendChild(thumb);
                thumbContainer.appendChild(deleteBtn);
                container.appendChild(thumbContainer);
            });
        }

        function spawnAvatar(username = 'Pengguna', message = '', isOwner = false) {
            if (characters.length === 0) {
                showError('Belum ada karakter dimuat!');
                return;
            }

            while (activeAvatars.length >= 5) { 
                activeAvatars.shift();
            }

            const char = characters[Math.floor(Math.random() * characters.length)];

            let initialX;
            let baseVx; // Store base velocity without speed multiplier
            let initialFlipped;

            if (Math.random() < 0.5) { 
                initialX = -parseInt(avatarSizeInput.value); 
                baseVx = (0.5 + Math.random() * 1.5); // Base speed
                initialFlipped = true; 
            } else { 
                initialX = canvas.width; 
                baseVx = -(0.5 + Math.random() * 1.5); // Base speed
                initialFlipped = false; 
            }

            const avatarDurationSeconds = parseInt(avatarDurationInput.value);
            const avatarMessageTimeout = avatarDurationSeconds * 1000;

            const newAvatar = {
                frames: char.frames,
                name: username,
                message: message,
                x: initialX,
                y: canvas.height - parseInt(avatarSizeInput.value), 
                originalVx: baseVx, // Store original base velocity
                vy: 0,
                born: Date.now(),
                alpha: 0,
                fadeIn: true,
                messageTimeout: avatarMessageTimeout, 
                width: parseInt(avatarSizeInput.value),
                height: parseInt(avatarSizeInput.value),
                currentFrame: 0,
                lastFrameTime: Date.now(),
                flipped: initialFlipped, 
                isBouncing: message.toLowerCase().includes('lompat'), 
                lastJumpTime: Date.now(), 
                isOwner: isOwner, 
                bubbleColor: isOwner ? '#FFD700' : subscriberBubbleColors[Math.floor(Math.random() * subscriberBubbleColors.length)],
                bubbleBounds: null 
            };

            activeAvatars.push(newAvatar);
        }

        function calculateBubbleData(tempCtx, avatar) {
            if (!avatar.message) return null;

            const bubblePadding = 10;
            const pointerWidth = 10; 
            const pointerHeightBase = 15; 
            const maxBubbleWidth = 300;
            const lineHeight = 18;
            const maxLines = 3;

            tempCtx.font = 'bold 14px Arial';
            const nameText = avatar.name + ': ';
            const nameWidth = tempCtx.measureText(nameText).width;

            let lines = [];
            let currentLine = '';
            const words = avatar.message.split(' ');

            for (let word of words) {
                const testLine = currentLine ? currentLine + ' ' + word : word;
                tempCtx.font = '14px Arial'; 
                const testWidth = tempCtx.measureText(testLine).width;

                if (testWidth + nameWidth > maxBubbleWidth - bubblePadding * 2 && lines.length < maxLines - 1) {
                    lines.push(currentLine);
                    currentLine = word;
                } else if (lines.length >= maxLines - 1 && testWidth + nameWidth > maxBubbleWidth - bubblePadding * 2) {
                    const remainingWidth = maxBubbleWidth - nameWidth - bubblePadding * 2;
                    let tempLine = currentLine;
                    while (tempCtx.measureText(tempLine + '...').width > remainingWidth && tempLine.length > 0) {
                        tempLine = tempLine.slice(0, -1);
                    }
                    currentLine = tempLine + '...';
                    break;
                } else {
                    currentLine = testLine;
                }
            }
            if (currentLine) lines.push(currentLine);

            tempCtx.font = '14px Arial';
            let textWidth = 0;
            for (const line of lines) {
                textWidth = Math.max(textWidth, tempCtx.measureText(line).width);
            }
            const bubbleWidth = Math.min(
                Math.max(textWidth + nameWidth + bubblePadding * 2, 70), 
                maxBubbleWidth
            );
            const textHeight = lines.length * lineHeight;

            let baseBubbleY = avatar.y - textHeight - bubblePadding - pointerHeightBase; 
            let bubbleX = avatar.x + (avatar.width / 2) - (bubbleWidth / 2);

            if (bubbleX < 10) bubbleX = 10;
            if (bubbleX + bubbleWidth > canvas.width - 10) bubbleX = canvas.width - bubbleWidth - 10;

            let currentPointerHeight = Math.max(pointerHeightBase, (avatar.y - 5) - (baseBubbleY + textHeight + bubblePadding));
            if (currentPointerHeight < 0) currentPointerHeight = pointerHeightBase; 

            const bubbleHeight = textHeight + bubblePadding + currentPointerHeight;

            return {
                lines,
                nameText, 
                nameWidth,
                bubbleWidth,
                textHeight,
                baseBubbleY,
                bubbleX,
                pointerWidth,
                pointerHeightBase, 
                calculatedPointerHeight: currentPointerHeight, 
                bubbleTotalHeight: bubbleHeight, 
                finalBubbleY: baseBubbleY 
            };
        }

        function drawActualBubble(ctx, avatar, bubbleData) {
            const { lines, nameText, nameWidth, bubbleWidth, textHeight, bubbleX, pointerWidth } = bubbleData;
            const finalBubbleY = bubbleData.finalBubbleY; 
            
            const bubblePadding = 10;
            const lineHeight = 18;
            const pointerYTop = finalBubbleY + textHeight + bubblePadding; 
            const pointerYBottom = avatar.y - 5; 

            ctx.save();
            ctx.globalAlpha = avatar.alpha * 0.9;
            ctx.fillStyle = avatar.bubbleColor; 
            
            if (avatar.isOwner) {
                const crownX = bubbleX + bubbleWidth / 2 - 10; 
                const crownY = finalBubbleY - 15; 

                ctx.beginPath();
                ctx.moveTo(crownX, crownY);
                ctx.lineTo(crownX + 5, crownY - 10);
                ctx.lineTo(crownX + 10, crownY);
                ctx.lineTo(crownX + 15, crownY - 10);
                ctx.lineTo(crownX + 20, crownY);
                ctx.lineTo(crownX, crownY); 
                ctx.closePath();
                ctx.fillStyle = '#FFD700'; 
                ctx.fill();
                ctx.strokeStyle = '#DAA520'; 
                ctx.lineWidth = 1;
                ctx.stroke();
            }

            ctx.beginPath();

            const radius = 8;
            ctx.moveTo(bubbleX + radius, finalBubbleY);
            ctx.lineTo(bubbleX + bubbleWidth - radius, finalBubbleY);
            ctx.quadraticCurveTo(bubbleX + bubbleWidth, finalBubbleY, bubbleX + bubbleWidth, finalBubbleY + radius);
            ctx.lineTo(bubbleX + bubbleWidth, pointerYTop - radius);
            ctx.quadraticCurveTo(bubbleX + bubbleWidth, pointerYTop, bubbleX + bubbleWidth - radius, pointerYTop);

            const pointerBaseX = avatar.x + avatar.width / 2; 
            
            if (pointerYBottom < pointerYTop) {
                ctx.lineTo(bubbleX + radius, pointerYTop); 
            } else {
                const pointerTipX = pointerBaseX; 
                const pointerLeftX = Math.max(bubbleX + radius, pointerTipX - pointerWidth / 2);
                const pointerRightX = Math.min(bubbleX + bubbleWidth - radius, pointerTipX + pointerWidth / 2);

                ctx.lineTo(pointerRightX, pointerYTop); 
                ctx.lineTo(pointerTipX, pointerYBottom); 
                ctx.lineTo(pointerLeftX, pointerYTop); 
                ctx.lineTo(bubbleX + radius, pointerYTop); 
            }
            
            ctx.quadraticCurveTo(bubbleX, pointerYTop, bubbleX, pointerYTop - radius);
            ctx.lineTo(bubbleX, finalBubbleY + radius);
            ctx.quadraticCurveTo(bubbleX, finalBubbleY, bubbleX + radius, finalBubbleY);
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = avatar.isOwner ? 'black' : 'white'; 
            let textY = finalBubbleY + bubblePadding + lineHeight - 4;

            ctx.font = 'bold 14px Arial';
            ctx.fillText(nameText, bubbleX + bubblePadding, textY);
            const nameXOffset = bubbleX + bubblePadding + nameWidth;

            ctx.font = '14px Arial';
            for (let i = 0; i < lines.length; i++) {
                ctx.fillText(lines[i], nameXOffset, textY + (i * lineHeight));
            }

            ctx.restore();

            avatar.bubbleBounds = {
                x: bubbleX,
                y: finalBubbleY,
                width: bubbleWidth,
                height: textHeight + bubblePadding + Math.max(0, pointerYBottom - pointerYTop) 
            };
        }


        function drawAllAvatars() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const now = Date.now();
            const currentAvatarSpeedMultiplier = parseFloat(avatarSpeedInput.value); // Get current speed multiplier

            const bubblesToDraw = [];
            for (let i = activeAvatars.length - 1; i >= 0; i--) {
                const avatar = activeAvatars[i];

                if (now - avatar.born > avatar.messageTimeout) {
                    activeAvatars.splice(i, 1);
                    continue; 
                }

                if (avatar.fadeIn) {
                    avatar.alpha = Math.min(1, avatar.alpha + 0.05);
                    if (avatar.alpha >= 1) avatar.fadeIn = false;
                }

                avatar.vy += 0.3; 
                // Apply speed multiplier to avatar's X movement using its originalVx
                avatar.x += avatar.originalVx * currentAvatarSpeedMultiplier; 
                avatar.y += avatar.vy;

                if (avatar.y >= canvas.height - avatar.height) {
                    avatar.y = canvas.height - avatar.height;
                    avatar.vy = 0; 
                }

                if (avatar.isBouncing && avatar.vy === 0 && (now - avatar.lastJumpTime >= 2000)) { 
                    avatar.vy = -(6 + Math.random() * 2); 
                    avatar.lastJumpTime = now; 
                }

                // Reverse direction if hitting boundaries
                // Note: originalVx is preserved, only its sign and magnitude for movement are considered
                if (avatar.x < 0) {
                    avatar.x = 0;
                    avatar.originalVx = Math.abs(avatar.originalVx); // Reverse direction
                    avatar.flipped = true; 
                } else if (avatar.x > canvas.width - avatar.width) {
                    avatar.x = canvas.width - avatar.width;
                    avatar.originalVx = -Math.abs(avatar.originalVx); // Reverse direction
                    avatar.flipped = false; 
                }

                const frame = avatar.frames[avatar.currentFrame];
                if (now - avatar.lastFrameTime > frame.delay) {
                    avatar.currentFrame = (avatar.currentFrame + 1) % avatar.frames.length;
                    avatar.lastFrameTime = now;
                }

                ctx.save();
                ctx.globalAlpha = avatar.alpha;
                if (avatar.flipped) { 
                    ctx.scale(-1, 1);
                    ctx.drawImage(frame.img, -avatar.x - avatar.width, avatar.y, avatar.width, avatar.height);
                    ctx.scale(-1, 1); 
                } else { 
                    ctx.drawImage(frame.img, avatar.x, avatar.y, avatar.width, avatar.height);
                }
                ctx.restore();

                const bubbleData = calculateBubbleData(ctx, avatar);
                if (bubbleData) {
                    bubblesToDraw.push({ avatar, bubbleData });
                }
            }

            bubblesToDraw.sort((a, b) => a.bubbleData.bubbleX - b.bubbleData.bubbleX || a.bubbleData.finalBubbleY - b.bubbleData.finalBubbleY);

            const collisionPadding = 5; 

            for (let i = 0; i < bubblesToDraw.length; i++) {
                const bubble1 = bubblesToDraw[i];
                
                let highestPointOccupied = bubble1.bubbleData.baseBubbleY;

                for (let j = 0; j < i; j++) {
                    const bubble2 = bubblesToDraw[j];

                    const horizontalOverlap = 
                        bubble1.bubbleData.bubbleX < bubble2.bubbleData.bubbleX + bubble2.bubbleData.bubbleWidth &&
                        bubble1.bubbleData.bubbleX + bubble1.bubbleData.bubbleWidth > bubble2.bubbleData.bubbleX;

                    if (horizontalOverlap) {
                        if (bubble1.bubbleData.baseBubbleY < bubble2.bubbleData.finalBubbleY + bubble2.bubbleData.bubbleTotalHeight + collisionPadding) {
                           highestPointOccupied = Math.min(
                               highestPointOccupied, 
                               bubble2.bubbleData.finalBubbleY - (bubble1.bubbleData.bubbleTotalHeight + collisionPadding)
                           );
                        }
                    }
                }
                bubble1.bubbleData.finalBubbleY = highestPointOccupied;

                if (bubble1.bubbleData.finalBubbleY < 10) {
                    bubble1.bubbleData.finalBubbleY = 10;
                }
            }

            bubblesToDraw.sort((a, b) => a.bubbleData.finalBubbleY - b.bubbleData.finalBubbleY);
            bubblesToDraw.forEach(({ avatar, bubbleData }) => {
                drawActualBubble(ctx, avatar, bubbleData);
            });
        }


        async function getLiveChatId(apiKey, videoId) {
            try {
                updateStatus('Mendapatkan ID live chat...');
                const response = await fetch(
                    `https://www.googleapis.com/youtube/v3/videos?part=liveStreamingDetails,snippet&id=${videoId}&key=${apiKey}`
                );

                if (!response.ok) {
                    const errorResponse = await response.json().catch(() => ({}));
                    console.error("YouTube API Error Response:", errorResponse);
                    throw new Error(`Error HTTP! status: ${response.status}. Detail: ${errorResponse.error?.message || 'Tidak ada detail.'}`);
                }

                const data = await response.json();

                if (!data.items || data.items.length === 0) {
                    throw new Error('Tidak menemukan video dengan ID tersebut atau video tidak aktif.');
                }

                ownerChannelId = data.items[0].snippet?.channelId;
                console.log('ID Channel Pemilik Ditemukan:', ownerChannelId);

                const chatId = data.items[0].liveStreamingDetails?.activeLiveChatId;
                if (!chatId) {
                    throw new Error('Video ini tidak memiliki live chat yang aktif');
                }

                return chatId;
            } catch (error) {
                showError(`Gagal mendapatkan ID live chat atau info video: ${error.message}`);
                throw error;
            }
        }

        async function pollLiveChat(apiKey, liveChatId) {
            if (!isRunning) return;

            try {
                updateStatus('Mengambil pesan chat...');

                const url = new URL('https://www.googleapis.com/youtube/v3/liveChat/messages');
                url.searchParams.append('liveChatId', liveChatId);
                url.searchParams.append('part', 'snippet,authorDetails');
                url.searchParams.append('key', apiKey);
                url.searchParams.append('maxResults', '200');

                if (nextPageToken) {
                    url.searchParams.append('pageToken', nextPageToken);
                }

                const response = await fetch(url);

                if (!response.ok) {
                    const errorResponse = await response.json().catch(() => ({}));
                    console.error("YouTube API Error Response:", errorResponse);
                    throw new Error(`Error HTTP! status: ${response.status}. Detail: ${errorResponse.error?.message || 'Tidak ada detail.'}`);
                }

                const data = await response.json();

                if (data.pollingIntervalMillis) {
                    pollingInterval = data.pollingIntervalMillis;
                }

                if (data.items && data.items.length > 0) {
                    const newMessages = data.items.filter(item => {
                        if (!item.snippet || item.snippet.type !== 'textMessageEvent' || processedMessageIds.has(item.id) || !item.authorDetails || !item.authorDetails.displayName) {
                            if (item.id && !processedMessageIds.has(item.id)) { 
                                console.warn("Skipping message (missing snippet/authorDetails/displayName or not textMessageEvent):", item);
                            }
                            return false;
                        }

                        const isOwner = ownerChannelId && item.authorDetails.channelId === ownerChannelId;
                        const isMember = item.authorDetails.isChatModerator || item.authorDetails.isChatOwner || item.authorDetails.isChatSponsor;
                        
                        if (isOwner || isMember) {
                            return true;
                        }
                        return false;
                    });

                    newMessages.forEach(item => {
                        const name = item.authorDetails.displayName || 'Anonim'; 
                        const message = item.snippet.displayMessage || '';
                        const isOwnerMessage = ownerChannelId && item.authorDetails.channelId === ownerChannelId; 

                        if (message.trim().length > 0) {
                            console.log(`Pesan baru: [${name}] ${message}`); 
                            spawnAvatar(name, message, isOwnerMessage); 
                            processedMessageIds.add(item.id); 
                        }
                    });
                    nextPageToken = data.nextPageToken; 
                    updateStatus(`Chat aktif - ${activeAvatars.length} avatar`);
                }

            } catch (error) {
                showError(error.message);
                updateStatus('Error - mencoba lagi dalam 10 detik...');
                if (isRunning) {
                    pollTimeout = setTimeout(() => pollLiveChat(apiKey, liveChatId), 10000);
                }
            } finally {
                if (isRunning) {
                    pollTimeout = setTimeout(() => pollLiveChat(apiKey, liveChatId), pollingInterval);
                }
            }
        }

        async function toggleLiveChat() {
            const apiKey = document.getElementById('apiKey').value.trim();
            const videoId = document.getElementById('videoId').value.trim();

            if (!apiKey) {
                showError('Kunci API YouTube diperlukan');
                return;
            }

            if (!videoId) {
                showError('ID video YouTube diperlukan');
                return;
            }

            if (isRunning) {
                stopLiveChat();
                return;
            }

            isRunning = true;
            startButton.textContent = 'Stop';
            startButton.disabled = true; 
            clearError();
            processedMessageIds.clear(); 

            try {
                const liveChatId = await getLiveChatId(apiKey, videoId);
                updateStatus(`Terhubung ke live chat: ${liveChatId.substring(0, 10)}...`);
                startButton.disabled = false;
                pollLiveChat(apiKey, liveChatId);
            } catch (error) {
                stopLiveChat(); 
            }
        }

        function stopLiveChat() {
            isRunning = false;
            clearTimeout(pollTimeout);
            startButton.textContent = 'Mulai';
            startButton.disabled = false;
            updateStatus('Terputus');
            nextPageToken = '';
            processedMessageIds.clear(); 
            ownerChannelId = null; 
        }

        function updateStatus(message) {
            statusElement.textContent = message;
            console.log(`Status: ${message}`);
        }

        function showError(message) {
            errorElement.textContent = ''; 
            errorElement.textContent = message; 
            console.error(message);
        }

        function clearError() {
            errorElement.textContent = '';
        }

        startButton.addEventListener('click', toggleLiveChat);
        animate();

        console.log('=== PETUNJUK SETUP OBS ===');
        console.log('1. Di OBS, tambahkan "Browser Source"');
        console.log('2. Set URL ke file HTML ini');
        console.log('3. Atur width/height sesuai kebutuhan (rekomendasi 1920x1080)');
        console.log('4. Centang "Shutdown source when not visible"');
        console.log('5. Tambahkan filter "Color Key"');
        console.log('   - Key color: #000000 (hitam)');
        console.log('   - Similarity: 150');
        console.log('   - Smoothness: 80');
        console.log('   - Blend: 10');
        console.log('6. Pastikan "Transparency" di browser source aktif');

        function animate() {
            drawAllAvatars();
            requestAnimationFrame(animate);
        }
    </script>
</body>
</html>